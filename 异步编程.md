# 前端异步编程

## 一、异步编程方式

### 1. 回调函数（Callback）

**概念**：将函数作为参数传递，在异步操作完成后调用。

**优点**：
- 实现简单，直观易懂
- 兼容性好，所有环境都支持

**缺点**：
- 容易陷入"回调地狱"（多层嵌套）
- 代码可读性差，难以维护
- 错误处理困难，每层都需要处理错误
- 不支持 `return` 和 `try/catch`

**适用场景**：简单的单层异步操作

---

### 2. Promise

**概念**：代表异步操作的最终完成或失败，返回一个包含结果的对象。

**优点**：
- 链式调用，避免回调地狱
- 统一的错误处理机制（`.catch()`）
- 支持 `Promise.all`、`Promise.race` 等组合操作
- 可读性比回调函数好

**缺点**：
- 无法取消 Promise
- 复杂流程仍可能产生较长的链式调用
- 需要理解 Promise 的状态机制（pending/fulfilled/rejected）
- 错误可能被静默吞掉（需手动 catch）

**适用场景**：多个异步操作需要串联或并行执行

---

### 3. async/await

**概念**：基于 Promise 的语法糖，让异步代码看起来像同步代码。

**优点**：
- 代码可读性极佳，接近同步写法
- 支持 `try/catch` 进行异常处理
- 调试友好，可以正常设置断点
- 避免链式调用，代码更简洁
- 处理多个异步操作更直观

**缺点**：
- 必须在 `async` 函数内使用 `await`
- 过度使用 `await` 会导致串行执行，影响性能
- 需要 ES2017+ 或 Babel 转译
- 仍然基于 Promise，底层问题依然存在

**适用场景**：复杂的异步流程，需要多个异步操作顺序执行

---

### 4. Generator + yield

**概念**：通过生成器函数配合 `yield` 实现异步流程控制。

**优点**：
- 可以暂停和恢复函数执行
- 流程控制更灵活
- 可以中断异步操作

**缺点**：
- 语法复杂，学习成本高
- 需要额外的执行器（如 co 库）
- 使用场景有限，已被 async/await 替代
- 可读性不如 async/await

**适用场景**：需要精细控制异步流程的场景（现已较少使用）

---

### 5. 事件发布订阅（Event Emitter）

**概念**：通过事件监听和触发实现异步通信。

**优点**：
- 解耦，发布者和订阅者互不依赖
- 一对多通信，一个事件可有多个监听者
- 适合复杂的异步事件流
- 灵活，可随时添加或移除监听器

**缺点**：
- 事件流追踪困难，难以调试
- 容易造成内存泄漏（忘记移除监听器）
- 不适合顺序执行的异步操作
- 事件命名容易冲突

**适用场景**：组件通信、事件驱动的系统、用户交互处理

---

### 6. Observable（RxJS）

**概念**：将异步操作视为可观察的数据流。

**优点**：
- 强大的操作符（map、filter、merge 等）
- 支持取消、重试、防抖等高级功能
- 适合处理复杂的异步数据流
- 统一处理各种异步场景

**缺点**：
- 学习曲线陡峭
- 库体积较大
- 过度使用会增加代码复杂度
- 需要理解函数式编程思想

**适用场景**：复杂的数据流处理、实时数据、多个异步源的组合

---

## 二、对比总结

| 方式 | 可读性 | 错误处理 | 学习成本 | 使用频率 | 推荐度 |
|------|--------|---------|---------|---------|--------|
| **回调函数** | ⭐ | ⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐ |
| **Promise** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **async/await** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Generator** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐ | ⭐ |
| **事件发布订阅** | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **Observable** | ⭐⭐ | ⭐⭐⭐⭐ | ⭐ | ⭐⭐ | ⭐⭐⭐ |

## 三、选择建议

### 现代项目首选

```
1. 简单异步：Promise
2. 复杂异步：async/await
3. 事件通信：事件发布订阅
4. 复杂数据流：Observable（RxJS）
```

### 演进历程

```
回调函数 → Promise → async/await（主流）
                ↓
            Generator（过渡方案，已淘汰）
```

### 实际应用

- **数据请求**：async/await
- **定时器/延时**：Promise
- **用户交互**：事件监听
- **组件通信**：事件发布订阅 / 状态管理
- **实时数据流**：Observable

## 四、面试要点

### 核心区别

1. **回调 vs Promise**：Promise 解决了回调地狱，提供了更好的错误处理
2. **Promise vs async/await**：async/await 是 Promise 的语法糖，可读性更好
3. **事件 vs Promise**：事件适合一对多通信，Promise 适合一对一异步操作

### 关键考点

- **Promise 三种状态**：pending（进行中）、fulfilled（成功）、rejected（失败）
- **Promise 链式调用**：`.then()` 返回新的 Promise
- **async/await 错误处理**：使用 `try/catch`
- **并发控制**：`Promise.all`（全部完成）、`Promise.race`（最快完成）、`Promise.allSettled`（全部结束）
- **事件内存泄漏**：及时移除事件监听器

### 常见面试题

1. **如何解决回调地狱？**  
   使用 Promise 链式调用或 async/await

2. **Promise 和 async/await 的区别？**  
   async/await 基于 Promise，是语法糖，可读性更好，支持 try/catch

3. **如何实现并发请求？**  
   使用 `Promise.all()` 或 `Promise.allSettled()`

4. **async 函数返回什么？**  
   总是返回 Promise 对象

5. **await 后面可以跟什么？**  
   可以跟任何值，非 Promise 会被自动包装成 Promise

## 五、最佳实践

1. ✅ **优先使用 async/await**，代码更清晰
2. ✅ **始终处理错误**，避免未捕获的 Promise rejection
3. ✅ **注意并发性能**，避免不必要的串行 await
4. ✅ **及时清理事件监听器**，防止内存泄漏
5. ❌ **避免回调嵌套**，超过 2 层就考虑重构
6. ❌ **不要滥用 Observable**，简单场景用 Promise 即可