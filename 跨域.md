<!--
 * @Author: mayuan17 mayuan17@meituan.com
 * @Date: 2026-02-04 13:13:39
 * @LastEditors: mayuan17 mayuan17@meituan.com
 * @LastEditTime: 2026-02-05 20:17:16
 * @FilePath: /Front-End-Note/跨域.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# 跨域问题与解决方案

## 一、同源策略

### 1.1 什么是同源策略

**同源策略**（Same-Origin Policy）是浏览器的一个安全功能，用于保证用户信息的安全，防止恶意网站窃取数据。

**同源的定义**：协议、域名和端口都相同的网页。

### 1.2 同源示例

```
URL 1: https://www.example.com:443/page1
URL 2: https://www.example.com:443/page2
结果：✅ 同源（协议、域名、端口都相同）

URL 1: https://www.example.com/page
URL 2: http://www.example.com/page
结果：❌ 不同源（协议不同：https vs http）

URL 1: https://www.example.com/page
URL 2: https://api.example.com/page
结果：❌ 不同源（域名不同：www vs api）

URL 1: https://www.example.com:443/page
URL 2: https://www.example.com:8080/page
结果：❌ 不同源（端口不同：443 vs 8080）
```

### 1.3 非同源受到的限制

当两个网页不同源时，以下行为会受到限制：

1. **Cookie、LocalStorage 和 IndexDB** 无法读取
2. **DOM** 无法获得
3. **AJAX 请求**不能发送（或者发送了但浏览器拦截响应）

## 二、跨域解决方案

### 2.1 针对 Cookie/DOM 的跨域方案

#### 方案一：修改 document.domain

**适用场景**：主域名相同，子域名不同的情况。

```javascript
// 页面 A：https://www.example.com/pageA.html
document.domain = 'example.com';
document.cookie = 'test=hello';

// 页面 B：https://sub.example.com/pageB.html
document.domain = 'example.com';
console.log(document.cookie); // 可以读取到 'test=hello'
```

**限制**：
- ⚠️ 只能用于主域名相同的情况
- ⚠️ 只能设置为当前域名或其父域名
- ⚠️ 端口会被重置为 `null`

#### 方案二：使用 window.name

**原理**：`window.name` 属性在窗口生命周期内保持不变，即使跨域导航也不会改变。

```javascript
// 1. 子窗口（https://other-domain.com/data.html）设置数据
window.name = JSON.stringify({
  user: 'Alice',
  token: 'xyz123'
});

// 2. 子窗口导航到与父窗口同域的页面
location.href = 'https://your-domain.com/proxy.html';

// 3. 父窗口读取数据
const iframe = document.createElement('iframe');
iframe.src = 'https://other-domain.com/data.html';
iframe.style.display = 'none';

iframe.onload = function() {
  // 第一次加载完成，改为同域地址
  iframe.onload = function() {
    // 第二次加载完成，可以读取了
    const data = JSON.parse(iframe.contentWindow.name);
    console.log(data);
    document.body.removeChild(iframe);
  };
  iframe.src = 'https://your-domain.com/proxy.html';
};

document.body.appendChild(iframe);
```

**特点**：
- ✅ 可以传输大量数据（2MB 左右）
- ⚠️ 实现复杂，已较少使用

#### 方案三：使用 window.postMessage（推荐）

**原理**：HTML5 提供的 API，允许跨窗口通信，不论是否同源。

**语法**：

```javascript
otherWindow.postMessage(message, targetOrigin, [transfer]);
```

**完整示例**：

```javascript
// 父窗口（https://parent.com）
const iframe = document.querySelector('iframe');

// 发送消息到子窗口
iframe.contentWindow.postMessage(
  { type: 'greeting', message: 'Hello from parent!' },
  'https://child.com'  // 指定目标源（安全考虑）
);

// 接收子窗口的消息
window.addEventListener('message', function(event) {
  // 安全检查：验证消息来源
  if (event.origin !== 'https://child.com') {
    return;
  }
  
  console.log('收到消息：', event.data);
  console.log('来源：', event.origin);
  console.log('来源窗口：', event.source);
});

// 子窗口（https://child.com）
// 接收父窗口的消息
window.addEventListener('message', function(event) {
  // 安全检查
  if (event.origin !== 'https://parent.com') {
    return;
  }
  
  console.log('收到父窗口消息：', event.data);
  
  // 回复消息
  event.source.postMessage(
    { type: 'reply', message: 'Hello from child!' },
    event.origin
  );
});
```

**实际应用场景**：

```javascript
// 场景1：iframe 通信
// 主页面
const iframe = document.getElementById('myIframe');
iframe.contentWindow.postMessage({ action: 'getData' }, '*');

window.addEventListener('message', (e) => {
  if (e.data.type === 'data') {
    console.log('接收到数据：', e.data.payload);
  }
});

// 场景2：window.open 通信
const newWindow = window.open('https://other-domain.com');
newWindow.postMessage({ token: 'abc123' }, 'https://other-domain.com');

// 场景3：Web Worker 通信
const worker = new Worker('worker.js');
worker.postMessage({ cmd: 'start', value: 100 });
worker.onmessage = (e) => {
  console.log('Worker 返回：', e.data);
};
```

**优点**：
- ✅ 安全可靠（需要验证 origin）
- ✅ 功能强大（支持各种跨窗口通信）
- ✅ 现代浏览器全部支持
- ✅ 可以传输结构化数据

### 2.2 针对 AJAX 请求的跨域方案

#### 方案一：JSONP（已过时）

**原理**：利用 `<script>` 标签不受同源策略限制的特性。

**实现步骤**：

1. 前端定义回调函数
2. 创建 `<script>` 标签，src 指向跨域 API
3. 服务器返回回调函数的调用，参数是数据
4. 浏览器执行返回的脚本，调用回调函数

**代码示例**：

```javascript
// 前端代码
function handleResponse(data) {
  console.log('收到数据：', data);
}

// 创建 script 标签
const script = document.createElement('script');
script.src = 'https://api.example.com/data?callback=handleResponse';
document.body.appendChild(script);

// 服务器返回（Node.js 示例）
// handleResponse({"name": "Alice", "age": 25})
```

**封装 JSONP**：

```javascript
function jsonp(url, params, callback) {
  return new Promise((resolve, reject) => {
    // 生成唯一的回调函数名
    const callbackName = `jsonp_${Date.now()}_${Math.random().toString(36).substr(2)}`;
    
    // 在全局注册回调函数
    window[callbackName] = function(data) {
      resolve(data);
      delete window[callbackName];
      document.body.removeChild(script);
    };
    
    // 构建 URL
    const queryString = Object.keys(params)
      .map(key => `${key}=${encodeURIComponent(params[key])}`)
      .join('&');
    
    const script = document.createElement('script');
    script.src = `${url}?${queryString}&callback=${callbackName}`;
    script.onerror = () => {
      reject(new Error('JSONP 请求失败'));
      delete window[callbackName];
      document.body.removeChild(script);
    };
    
    document.body.appendChild(script);
  });
}

// 使用示例
jsonp('https://api.example.com/data', { id: 123 })
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

**服务器端实现（Node.js + Express）**：

```javascript
app.get('/data', (req, res) => {
  const callback = req.query.callback;
  const data = { name: 'Alice', age: 25 };
  
  // 返回 JavaScript 代码
  res.send(`${callback}(${JSON.stringify(data)})`);
});
```

**优缺点**：

- ✅ 简单易用
- ✅ 兼容老式浏览器
- ❌ **只支持 GET 请求**
- ❌ 安全性差（容易遭受 XSS 攻击）
- ❌ 错误处理困难
- ⚠️ 已过时，不推荐使用

#### 方案二：WebSocket

**原理**：WebSocket 协议不实行同源策略，只要服务器支持即可跨域通信。

**基本使用**：

```javascript
// 前端代码
const socket = new WebSocket('wss://api.example.com/socket');

// 连接建立
socket.addEventListener('open', (event) => {
  console.log('WebSocket 连接已建立');
  socket.send('Hello Server!');
});

// 接收消息
socket.addEventListener('message', (event) => {
  console.log('收到服务器消息：', event.data);
});

// 连接关闭
socket.addEventListener('close', (event) => {
  console.log('WebSocket 连接已关闭');
});

// 错误处理
socket.addEventListener('error', (event) => {
  console.error('WebSocket 错误：', event);
});
```

**服务器端实现（Node.js + ws）**：

```javascript
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  console.log('客户端已连接');
  
  // 接收消息
  ws.on('message', (message) => {
    console.log('收到消息：', message);
    
    // 发送消息
    ws.send(`服务器收到：${message}`);
  });
  
  // 连接关闭
  ws.on('close', () => {
    console.log('客户端已断开');
  });
});
```

**优点**：
- ✅ 支持双向通信
- ✅ 实时性强
- ✅ 不受同源策略限制
- ✅ 支持二进制数据传输

**适用场景**：
- 实时聊天
- 在线游戏
- 实时数据推送
- 协同编辑

#### 方案三：CORS（推荐）⭐

**原理**：CORS（Cross-Origin Resource Sharing）跨域资源共享，是 W3C 标准，是跨域 AJAX 请求的根本解决方案。

**实现方式**：服务器在响应头中添加特定的 CORS 头部。

**简单请求 vs 预检请求**：

```
简单请求（Simple Request）：
- 请求方法：GET、HEAD、POST
- 请求头：Accept、Accept-Language、Content-Language、
         Content-Type（仅限 application/x-www-form-urlencoded、
         multipart/form-data、text/plain）

预检请求（Preflight Request）：
- 不满足简单请求条件的请求
- 会先发送 OPTIONS 请求询问服务器
```

**服务器端配置（Node.js + Express）**：

```javascript
const express = require('express');
const app = express();

// 方式1：手动设置 CORS 头部
app.use((req, res, next) => {
  // 允许的源（* 表示允许所有源，生产环境应指定具体域名）
  res.header('Access-Control-Allow-Origin', 'https://your-domain.com');
  
  // 允许的请求方法
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  
  // 允许的请求头
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  
  // 允许携带凭证（Cookie）
  res.header('Access-Control-Allow-Credentials', 'true');
  
  // 预检请求的缓存时间（秒）
  res.header('Access-Control-Max-Age', '86400');
  
  // 暴露给前端的响应头
  res.header('Access-Control-Expose-Headers', 'X-Custom-Header');
  
  // 处理 OPTIONS 预检请求
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  
  next();
});

// 方式2：使用 cors 中间件（推荐）
const cors = require('cors');

// 允许所有源
app.use(cors());

// 自定义配置
app.use(cors({
  origin: 'https://your-domain.com',  // 允许的源
  methods: ['GET', 'POST', 'PUT', 'DELETE'],  // 允许的方法
  allowedHeaders: ['Content-Type', 'Authorization'],  // 允许的请求头
  credentials: true,  // 允许携带凭证
  maxAge: 86400  // 预检请求缓存时间
}));

// 动态配置（根据请求源决定）
app.use(cors({
  origin: function(origin, callback) {
    const allowedOrigins = [
      'https://your-domain.com',
      'https://another-domain.com'
    ];
    
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
}));

// API 路由
app.get('/api/data', (req, res) => {
  res.json({ message: 'CORS 请求成功！' });
});

app.listen(3000);
```

**前端代码**：

```javascript
// 简单请求
fetch('https://api.example.com/data')
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => console.error(err));

// 携带凭证（Cookie）
fetch('https://api.example.com/data', {
  method: 'GET',
  credentials: 'include'  // 携带 Cookie
})
  .then(res => res.json())
  .then(data => console.log(data));

// 自定义请求头（会触发预检请求）
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123'
  },
  credentials: 'include',
  body: JSON.stringify({ name: 'Alice' })
})
  .then(res => res.json())
  .then(data => console.log(data));

// 使用 axios
axios.get('https://api.example.com/data', {
  withCredentials: true  // 携带 Cookie
})
  .then(res => console.log(res.data))
  .catch(err => console.error(err));
```

**CORS 响应头详解**：

| 响应头 | 说明 | 示例 |
|--------|------|------|
| `Access-Control-Allow-Origin` | 允许的源 | `https://example.com` 或 `*` |
| `Access-Control-Allow-Methods` | 允许的 HTTP 方法 | `GET, POST, PUT, DELETE` |
| `Access-Control-Allow-Headers` | 允许的请求头 | `Content-Type, Authorization` |
| `Access-Control-Allow-Credentials` | 是否允许携带凭证 | `true` |
| `Access-Control-Max-Age` | 预检请求缓存时间 | `86400`（秒） |
| `Access-Control-Expose-Headers` | 暴露给前端的响应头 | `X-Custom-Header` |

**优点**：
- ✅ 官方标准解决方案
- ✅ 支持所有 HTTP 方法
- ✅ 功能强大，配置灵活
- ✅ 安全可控
- ✅ 现代浏览器全部支持

**注意事项**：
- ⚠️ 携带凭证时，`Access-Control-Allow-Origin` 不能设置为 `*`
- ⚠️ 需要服务器端配合
- ⚠️ IE10 以下不支持

#### 方案四：代理服务器（开发环境推荐）

**原理**：同源策略是浏览器的限制，服务器之间通信不受此限制。

**Webpack DevServer 配置**：

```javascript
// webpack.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'https://api.example.com',  // 目标服务器
        changeOrigin: true,  // 改变请求源
        pathRewrite: {
          '^/api': ''  // 重写路径：/api/users -> /users
        }
      }
    }
  }
};

// 前端请求（相对路径，自动代理）
fetch('/api/users')
  .then(res => res.json())
  .then(data => console.log(data));
```

**Vite 配置**：

```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'https://api.example.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
};
```

**Nginx 反向代理（生产环境）**：

```nginx
server {
  listen 80;
  server_name your-domain.com;
  
  # 前端页面
  location / {
    root /var/www/html;
    index index.html;
  }
  
  # API 代理
  location /api/ {
    proxy_pass https://api.example.com/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}
```

**优点**：
- ✅ 前端无需修改代码
- ✅ 支持所有请求类型
- ✅ 完全绕过浏览器同源策略

**适用场景**：
- 开发环境（Webpack/Vite DevServer）
- 生产环境（Nginx 反向代理）

## 三、跨域解决方案对比

| 方案 | 适用场景 | 优点 | 缺点 | 推荐度 |
|------|---------|------|------|--------|
| **CORS** | AJAX 请求 | 官方标准，功能强大 | 需要服务器配合 | ⭐⭐⭐⭐⭐ |
| **代理服务器** | 开发/生产环境 | 简单易用，无需改代码 | 需要配置服务器 | ⭐⭐⭐⭐⭐ |
| **postMessage** | iframe/window 通信 | 安全可靠，功能强大 | 只适用于窗口通信 | ⭐⭐⭐⭐ |
| **WebSocket** | 实时双向通信 | 实时性强，不受同源限制 | 需要特殊服务器 | ⭐⭐⭐⭐ |
| **JSONP** | 简单 GET 请求 | 兼容老浏览器 | 只支持 GET，不安全 | ⭐ (已过时) |
| **document.domain** | 主域相同的子域 | 实现简单 | 限制多，不安全 | ⭐ (不推荐) |

## 四、最佳实践

### 4.1 推荐方案

**现代 Web 应用**：
```
1. AJAX 请求：使用 CORS（服务器端配置）✅
2. 开发环境：使用 DevServer 代理 ✅
3. 生产环境：使用 Nginx 反向代理 ✅
4. 窗口通信：使用 postMessage ✅
5. 实时通信：使用 WebSocket ✅
```

### 4.2 安全建议

```javascript
// ✅ 推荐：明确指定允许的源
res.header('Access-Control-Allow-Origin', 'https://trusted-domain.com');

// ❌ 不推荐：允许所有源（存在安全风险）
res.header('Access-Control-Allow-Origin', '*');

// ✅ 推荐：验证 postMessage 来源
window.addEventListener('message', (event) => {
  if (event.origin !== 'https://trusted-domain.com') {
    return;  // 忽略不可信的消息
  }
  // 处理消息
});

// ✅ 推荐：动态设置允许的源
const allowedOrigins = ['https://domain1.com', 'https://domain2.com'];
const origin = req.headers.origin;
if (allowedOrigins.includes(origin)) {
  res.header('Access-Control-Allow-Origin', origin);
}
```

### 4.3 调试技巧

```javascript
// 1. 查看浏览器控制台的 CORS 错误信息
// 错误示例：
// Access to fetch at 'xxx' from origin 'yyy' has been blocked by CORS policy

// 2. 检查请求头和响应头
// Chrome DevTools -> Network -> 选择请求 -> Headers

// 3. 验证预检请求
// 查看是否有 OPTIONS 请求
// 检查 Access-Control-Allow-* 响应头

// 4. 使用浏览器扩展临时禁用 CORS（仅用于开发测试）
// Chrome: CORS Unblock
// Firefox: CORS Everywhere
```

## 五、总结

### 5.1 核心要点

1. **同源策略**是浏览器的安全机制，限制跨域资源访问
2. **CORS** 是现代 Web 应用跨域的标准解决方案
3. **代理服务器**在开发和生产环境都很实用
4. **postMessage** 是跨窗口通信的最佳选择
5. **JSONP** 已过时，不推荐使用

### 5.2 快速决策

```
需要 AJAX 跨域？
  ↓
  服务器可控？
    ├─ 是 → 使用 CORS ✅
    └─ 否 → 使用代理服务器 ✅

需要窗口通信？
  ↓
  使用 postMessage ✅

需要实时通信？
  ↓
  使用 WebSocket ✅
```

## 参考资料

- [MDN - Same-origin policy](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)
- [MDN - CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)
- [MDN - postMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)
- [阮一峰 - 跨域资源共享 CORS 详解](https://www.ruanyifeng.com/blog/2016/04/cors.html)
- [阮一峰 - 浏览器同源政策及其规避方法](https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)