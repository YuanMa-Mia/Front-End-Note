# 事件流与事件委托

## 一、事件流模型

JavaScript 中事件流模型分为三个阶段：**事件捕获**、**事件目标**、**事件冒泡**。

### 1.1 事件流的三个阶段

```
Window
  ↓ 捕获阶段
Document
  ↓
<html>
  ↓
<body>
  ↓
<div>
  ↓
目标元素 ← 目标阶段
  ↑
<div>
  ↑ 冒泡阶段
<body>
  ↑
<html>
  ↑
Document
  ↑
Window
```

1. **第一阶段：捕获阶段（Capture Phase）**
   - 事件从`window`对象传导到目标节点
   - 由外向内传播

2. **第二阶段：目标阶段（Target Phase）**
   - 事件在目标节点上触发
   - 实际触发事件处理函数

3. **第三阶段：冒泡阶段（Bubble Phase）**
   - 事件从目标节点传回`window`对象
   - 由内向外传播

### 1.2 事件流示意图

```
┌─────────────────────────────────────────────────────────┐
│                      事件流过程                          │
└─────────────────────────────────────────────────────────┘

捕获阶段 (Capturing)          目标阶段           冒泡阶段 (Bubbling)
    ↓                       (Target)                ↑
Window ────────────────────────────────────────→ Window
    ↓                                               ↑
Document ──────────────────────────────────────→ Document
    ↓                                               ↑
  <html> ──────────────────────────────────────→ <html>
    ↓                                               ↑
  <body> ──────────────────────────────────────→ <body>
    ↓                                               ↑
   <div> ──────────────────────────────────────→  <div>
    ↓                                               ↑
    └──────────────→ [目标元素] ──────────────────┘
```

## 二、事件处理

### 2.1 阻止事件冒泡

使用 `stopPropagation()` 方法阻止事件继续传播：

```javascript
element.addEventListener('click', function(event) {
  event.stopPropagation(); // 阻止事件冒泡
  console.log('事件不会继续向上传播');
});
```

### 2.2 阻止默认行为

使用 `preventDefault()` 方法阻止元素的默认行为：

```javascript
link.addEventListener('click', function(event) {
  event.preventDefault(); // 阻止链接跳转
  console.log('链接不会跳转');
});

form.addEventListener('submit', function(event) {
  event.preventDefault(); // 阻止表单提交
  console.log('表单不会提交');
});
```

### 2.3 addEventListener 参数详解

```javascript
element.addEventListener(type, listener, options);
```

**参数说明**：

1. **type**（必需）：字符串，表示监听的事件类型，如 `'click'`、`'mouseenter'` 等

2. **listener**（必需）：事件处理函数，当事件触发时执行

3. **options/useCapture**（可选）：
   - **布尔值**：`true` 表示捕获阶段触发，`false`（默认）表示冒泡阶段触发
   - **对象**：可包含以下属性
     - `capture`：布尔值，是否在捕获阶段触发
     - `once`：布尔值，是否只触发一次
     - `passive`：布尔值，是否永远不会调用 `preventDefault()`

**示例**：

```javascript
// 在冒泡阶段触发（默认）
element.addEventListener('click', handler, false);

// 在捕获阶段触发
element.addEventListener('click', handler, true);

// 使用选项对象
element.addEventListener('click', handler, {
  capture: false,  // 冒泡阶段
  once: true,      // 只触发一次
  passive: true    // 不会调用preventDefault()
});
```

## 三、事件委托

### 3.1 概念

**事件委托**（Event Delegation）是利用事件冒泡机制，把原本绑定在多个子元素上的事件处理器，统一绑定到父元素上。

父元素通过判断 `event.target` 来确定实际的事件源，从而执行相应的操作。

### 3.2 工作原理

```
┌─────────────────────────────────────┐
│         父元素（事件监听器）         │
│  ┌────┐  ┌────┐  ┌────┐  ┌────┐    │
│  │子1 │  │子2 │  │子3 │  │子4 │    │
│  └────┘  └────┘  └────┘  └────┘    │
└─────────────────────────────────────┘
       ↑
       └─ 点击任何子元素，事件冒泡到父元素
          父元素通过 event.target 判断是哪个子元素
```

### 3.3 代码示例

**传统方式（不推荐）**：

```javascript
// ❌ 为每个子元素都绑定事件
const items = document.querySelectorAll('.item');
items.forEach(item => {
  item.addEventListener('click', function(e) {
    console.log('点击了：', this.textContent);
  });
});
// 问题：子元素多时性能差，动态添加的元素无法监听
```

**事件委托方式（推荐）**：

```javascript
// ✅ 只在父元素上绑定一个事件
const list = document.querySelector('.list');
list.addEventListener('click', function(e) {
  // 判断点击的是否是目标元素
  if (e.target.classList.contains('item')) {
    console.log('点击了：', e.target.textContent);
  }
});
// 优点：性能好，动态添加的元素也能监听
```

**更完善的事件委托示例**：

```javascript
const list = document.querySelector('.list');

list.addEventListener('click', function(e) {
  // 向上查找，找到最近的匹配元素
  const item = e.target.closest('.item');
  
  if (item) {
    // 判断具体的操作
    if (e.target.classList.contains('delete-btn')) {
      // 删除操作
      item.remove();
    } else if (e.target.classList.contains('edit-btn')) {
      // 编辑操作
      console.log('编辑：', item.dataset.id);
    } else {
      // 点击item本身
      console.log('查看详情：', item.textContent);
    }
  }
});
```

### 3.4 事件委托的优点

1. **减少内存占用**
   - 只需在父元素上绑定一个事件处理器
   - 避免为每个子元素都绑定事件

2. **动态元素支持**
   - 新增的子元素自动具有事件处理能力
   - 无需为新元素重新绑定事件

3. **代码简洁**
   - 统一管理事件逻辑
   - 易于维护

4. **性能优化**
   - 减少事件处理器数量
   - 降低DOM操作开销

### 3.5 适用场景

事件委托特别适用于以下场景：

- ✅ 动态列表（如无限滚动加载的列表）
- ✅ 表格操作（增删改查）
- ✅ 大量相似元素的交互
- ✅ 频繁添加/删除的DOM元素

### 3.6 注意事项

1. **不是所有事件都适合委托**
   - 某些事件不冒泡（如 `focus`、`blur`、`scroll`）
   - 可以使用对应的冒泡事件（`focusin`、`focusout`）

2. **性能考虑**
   - 委托的层级不宜过深
   - 避免在 `document` 或 `body` 上委托大量事件

3. **事件目标判断**
   - 使用 `event.target` 获取实际触发元素
   - 使用 `event.currentTarget` 获取绑定事件的元素
   - 使用 `closest()` 方法向上查找匹配的祖先元素
