# JavaScript 模块化

## 一、模块化的好处

- ✅ **避免命名冲突**：减少命名空间污染，每个模块有独立作用域
- ✅ **更好的分离**：按需加载，提高首屏加载速度
- ✅ **更高复用性**：模块可以在不同项目中复用
- ✅ **高可维护性**：代码结构清晰，便于维护和协作开发
- ✅ **依赖管理**：明确模块间的依赖关系

## 二、模块化规范

### 2.1 CommonJS

#### 概述

Node.js 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。

- **服务器端**：模块的加载是运行时**同步加载**的
- **浏览器端**：模块需要提前编译打包处理（使用 Browserify 等工具）

#### 特点

1. **模块作用域**：所有代码都运行在模块作用域，不会污染全局作用域
2. **模块缓存**：模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存
3. **加载顺序**：模块加载的顺序，按照其在代码中出现的顺序
4. **值的拷贝**：CommonJS 模块输出的是值的**拷贝**，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值

#### 基本语法

**导出模块**：

```javascript
// 方式1：exports.xxx
exports.foo = function() {
  console.log('foo');
};
exports.bar = 'bar';

// 方式2：module.exports（推荐）
module.exports = {
  foo: function() {
    console.log('foo');
  },
  bar: 'bar'
};

// 或者直接导出单个值/函数/类
module.exports = function() {
  console.log('single function');
};
```

**导入模块**：

```javascript
// 导入第三方模块（node_modules中的模块）
const express = require('express');
const lodash = require('lodash');

// 导入自定义模块（使用相对路径或绝对路径）
const myModule = require('./myModule');
const utils = require('../utils/helper');

// 解构导入
const { foo, bar } = require('./myModule');
```

#### 示例

```javascript
// math.js
let count = 0;

function add(a, b) {
  count++;
  return a + b;
}

function getCount() {
  return count;
}

module.exports = {
  add,
  getCount
};

// app.js
const math = require('./math');

console.log(math.add(1, 2)); // 3
console.log(math.getCount()); // 1

// 再次引入，使用缓存
const math2 = require('./math');
console.log(math === math2); // true（同一个对象）
```

### 2.2 AMD（Asynchronous Module Definition）

#### 概述

AMD 规范采用**异步方式**加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。

- **环境**：主要用于浏览器端
- **代表**：RequireJS
- **优势**：适合浏览器环境，避免同步加载阻塞页面渲染

#### 为什么需要 AMD？

CommonJS 规范加载模块是同步的，这在服务器端没有问题（文件在本地硬盘），但在浏览器端，如果同步加载模块，会阻塞页面渲染，影响用户体验。因此浏览器端需要异步加载方案。

#### 基本语法

**定义模块**：

```javascript
// 定义没有依赖的模块
define(function() {
  function add(a, b) {
    return a + b;
  }
  
  // 返回模块
  return {
    add: add
  };
});

// 定义有依赖的模块
define(['module1', 'module2'], function(m1, m2) {
  function doSomething() {
    m1.method();
    m2.method();
  }
  
  // 返回模块
  return {
    doSomething: doSomething
  };
});
```

**引入使用模块**：

```javascript
// 引入模块
require(['module1', 'module2'], function(m1, m2) {
  // 使用模块
  m1.doSomething();
  m2.doSomething();
});
```

#### 完整示例

```javascript
// math.js - 定义模块
define(function() {
  function add(a, b) {
    return a + b;
  }
  
  function subtract(a, b) {
    return a - b;
  }
  
  return {
    add: add,
    subtract: subtract
  };
});

// calculator.js - 依赖其他模块
define(['math'], function(math) {
  function calculate(a, b) {
    console.log('Add:', math.add(a, b));
    console.log('Subtract:', math.subtract(a, b));
  }
  
  return {
    calculate: calculate
  };
});

// main.js - 使用模块
require(['calculator'], function(calculator) {
  calculator.calculate(5, 3);
});
```

### 2.3 CMD（Common Module Definition）

#### 概述

CMD 规范整合了 CommonJS 和 AMD 规范的特点：

- **环境**：专门用于浏览器端
- **代表**：Sea.js
- **特点**：模块的加载是异步的，模块使用时才会加载执行（懒加载）

#### CMD vs AMD

| 特性 | AMD | CMD |
|------|-----|-----|
| **依赖处理** | 依赖前置，提前加载 | 依赖就近，延迟执行 |
| **执行时机** | 依赖加载完立即执行 | 使用时才执行 |
| **写法** | 依赖必须在开头声明 | 依赖可以在任何地方引入 |

#### 基本语法

**定义模块**：

```javascript
// 定义没有依赖的模块
define(function(require, exports, module) {
  // 模块代码
  function add(a, b) {
    return a + b;
  }
  
  // 导出方式1
  exports.add = add;
  
  // 导出方式2
  module.exports = {
    add: add
  };
});

// 定义有依赖的模块
define(function(require, exports, module) {
  // 同步引入依赖模块
  var module1 = require('./module1');
  
  // 异步引入依赖模块
  require.async('./module2', function(m2) {
    m2.doSomething();
  });
  
  function doSomething() {
    module1.method();
  }
  
  // 导出模块
  exports.doSomething = doSomething;
});
```

**引入使用模块**：

```javascript
define(function(require) {
  // 就近引入依赖
  var m1 = require('./module1');
  var m2 = require('./module2');
  
  // 使用模块
  m1.show();
  m2.show();
});
```

#### AMD vs CMD 示例对比

```javascript
// AMD - 依赖前置
define(['a', 'b'], function(a, b) {
  // a 和 b 模块已经加载并执行完成
  a.doSomething();
  
  if (false) {
    b.doSomething(); // 即使不执行，b 也已经加载了
  }
});

// CMD - 依赖就近
define(function(require, exports, module) {
  var a = require('./a'); // 此时才加载并执行 a
  a.doSomething();
  
  if (false) {
    var b = require('./b'); // 不会执行这里，b 不会加载
  }
});
```

### 2.4 UMD（Universal Module Definition）

#### 概述

UMD 是**通用模块定义**规范，目标是使一个模块能在各种环境下运行：

- ✅ 支持 AMD 规范
- ✅ 支持 CommonJS 规范
- ✅ 支持浏览器全局变量

#### 实现原理

UMD 通过判断当前环境支持的模块规范，来决定使用哪种方式导出模块：

1. 先判断是否支持 AMD（`define` 是否存在），存在则使用 AMD 方式加载模块
2. 再判断是否支持 Node.js 模块格式（`exports` 是否存在），存在则使用 Node.js 模块格式
3. 前两个都不存在，则将模块公开到全局（`window` 或 `global`）

#### 基本模板

```javascript
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD 环境
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    // Node/CommonJS 环境
    module.exports = factory(require('jquery'));
  } else {
    // 浏览器全局变量（root 即 window）
    root.myModule = factory(root.jQuery);
  }
})(typeof self !== 'undefined' ? self : this, function($) {
  // 模块代码
  function myFuncA() {
    // 私有方法，因为没有返回
    console.log('private function');
  }
  
  function myFuncB() {
    // 公共方法，因为返回了
    console.log('public function');
    myFuncA();
  }

  // 暴露公共方法
  return {
    myFuncB: myFuncB
  };
});
```

#### 使用示例

```javascript
// 完整的 UMD 模块示例
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node/CommonJS
    module.exports = factory();
  } else {
    // 浏览器全局变量
    root.Calculator = factory();
  }
}(typeof self !== 'undefined' ? self : this, function() {
  'use strict';
  
  // 私有变量
  let history = [];
  
  // 私有方法
  function log(operation, result) {
    history.push({ operation, result });
  }
  
  // 公共方法
  function add(a, b) {
    const result = a + b;
    log('add', result);
    return result;
  }
  
  function getHistory() {
    return history.slice(); // 返回副本
  }
  
  // 暴露公共 API
  return {
    add: add,
    getHistory: getHistory
  };
}));
```

### 2.5 ES6 模块化（ESM）

#### 概述

ES6 在语言标准层面上实现了模块功能，是目前最推荐使用的模块化方案。

- **静态化**：编译时就能确定模块的依赖关系，以及输入和输出的变量
- **异步加载**：ES6 模块是异步加载，有独立的模块依赖解析阶段
- **值的引用**：ES6 模块输出的是值的**引用**，而不是值的拷贝
- **动态绑定**：模块里面的变量绑定其所在的模块

#### 基本语法

**导出模块**：

```javascript
// 命名导出（可以有多个）
export const name = 'Module';
export function add(a, b) {
  return a + b;
}
export class Calculator {
  // ...
}

// 或者统一导出
const name = 'Module';
function add(a, b) {
  return a + b;
}
class Calculator {
  // ...
}
export { name, add, Calculator };

// 导出时重命名
export { add as sum, Calculator as Calc };

// 默认导出（一个模块只能有一个）
export default function() {
  console.log('default export');
}

// 或者
function myFunction() {
  console.log('default export');
}
export default myFunction;
```

**导入模块**：

```javascript
// 导入命名导出
import { name, add, Calculator } from './module.js';

// 导入时重命名
import { add as sum, Calculator as Calc } from './module.js';

// 导入所有命名导出
import * as myModule from './module.js';
console.log(myModule.name);
console.log(myModule.add(1, 2));

// 导入默认导出
import myFunction from './module.js';

// 同时导入默认导出和命名导出
import myFunction, { name, add } from './module.js';

// 仅执行模块（不导入任何内容）
import './module.js';
```

#### 动态导入

```javascript
// 动态导入（返回 Promise）
button.addEventListener('click', async () => {
  const module = await import('./module.js');
  module.doSomething();
});

// 或者使用 .then()
import('./module.js')
  .then(module => {
    module.doSomething();
  })
  .catch(err => {
    console.error('加载失败', err);
  });
```

#### 完整示例

```javascript
// math.js
let count = 0;

export function add(a, b) {
  count++;
  return a + b;
}

export function subtract(a, b) {
  count++;
  return a - b;
}

export function getCount() {
  return count;
}

export const PI = 3.14159;

// calculator.js
import { add, subtract, getCount } from './math.js';

export default class Calculator {
  calculate(a, b) {
    console.log('Add:', add(a, b));
    console.log('Subtract:', subtract(a, b));
    console.log('Count:', getCount());
  }
}

// app.js
import Calculator from './calculator.js';
import { PI } from './math.js';

const calc = new Calculator();
calc.calculate(10, 5);
console.log('PI:', PI);
```

#### ES6 模块与 CommonJS 模块的差异

| 特性 | CommonJS | ES6 Module |
|------|----------|------------|
| **加载时机** | 运行时加载 | 编译时加载（静态加载） |
| **加载方式** | 同步加载 | 异步加载 |
| **输出** | 值的拷贝 | 值的引用（动态绑定） |
| **this 指向** | 指向当前模块 | undefined |
| **循环依赖** | 加载时执行，可能只加载部分 | 支持循环依赖，动态绑定 |
| **顶层变量** | 模块内部 | 模块内部（不在全局） |

#### 详细差异说明

**1. 值的拷贝 vs 值的引用**

```javascript
// CommonJS - 值的拷贝
// counter.js
let count = 0;
function increment() {
  count++;
}
module.exports = {
  count,      // 导出的是值的拷贝
  increment
};

// app.js
const counter = require('./counter');
console.log(counter.count); // 0
counter.increment();
console.log(counter.count); // 0（仍然是0，因为是拷贝）

// ===================================

// ES6 Module - 值的引用
// counter.js
export let count = 0;
export function increment() {
  count++;
}

// app.js
import { count, increment } from './counter.js';
console.log(count); // 0
increment();
console.log(count); // 1（值已更新，因为是引用）
```

**2. 运行时加载 vs 编译时加载**

```javascript
// CommonJS - 运行时加载（动态）
const moduleName = condition ? './moduleA' : './moduleB';
const module = require(moduleName); // ✅ 可以

// ES6 Module - 编译时加载（静态）
const moduleName = condition ? './moduleA' : './moduleB';
import module from moduleName; // ❌ 报错：import 必须在顶层

// 但可以使用动态 import
const module = await import(moduleName); // ✅ 可以
```

**3. 循环依赖处理**

```javascript
// CommonJS - 循环依赖
// a.js
exports.done = false;
const b = require('./b.js');
console.log('在 a.js 中，b.done =', b.done);
exports.done = true;

// b.js
exports.done = false;
const a = require('./a.js');
console.log('在 b.js 中，a.done =', a.done); // false（未完成）
exports.done = true;

// ===================================

// ES6 Module - 循环依赖
// a.js
import { bar } from './b.js';
export function foo() {
  console.log('foo');
  bar();
}
foo();

// b.js
import { foo } from './a.js';
export function bar() {
  console.log('bar');
  if (Math.random() > 0.5) {
    foo(); // 可以调用，因为是动态绑定
  }
}
```

## 三、模块化规范对比总结

### 3.1 对比表格

| 规范 | 环境 | 加载方式 | 特点 | 代表 |
|------|------|---------|------|------|
| **CommonJS** | 服务器端 | 同步加载 | 值的拷贝，运行时加载 | Node.js |
| **AMD** | 浏览器端 | 异步加载 | 依赖前置，提前执行 | RequireJS |
| **CMD** | 浏览器端 | 异步加载 | 依赖就近，延迟执行 | Sea.js |
| **UMD** | 通用 | 兼容多种 | 兼容 AMD/CommonJS/全局变量 | - |
| **ES6 Module** | 通用 | 异步加载 | 值的引用，编译时加载，官方标准 | 现代浏览器/Node.js |

### 3.2 选择建议

- ✅ **新项目**：优先使用 **ES6 Module**（官方标准，现代化）
- ✅ **Node.js 项目**：使用 **CommonJS** 或 **ES6 Module**（Node.js 12+ 支持 ESM）
- ✅ **浏览器兼容**：使用构建工具（Webpack、Rollup 等）将 ES6 Module 转换
- ✅ **库开发**：考虑使用 **UMD** 格式，兼容多种环境
- ⚠️ **AMD/CMD**：已过时，不推荐新项目使用

### 3.3 现代开发实践

```javascript
// 推荐：使用 ES6 Module
import React from 'react';
import { useState, useEffect } from 'react';
import axios from 'axios';
import './styles.css';

export default function App() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    axios.get('/api/data').then(res => {
      setData(res.data);
    });
  }, []);
  
  return <div>{data}</div>;
}

// 构建工具会处理模块转换和打包
```

## 四、总结

### 4.1 模块化演进历程

```
无模块化 → 全局函数模式 → namespace 模式 → IIFE
  ↓
CommonJS（Node.js）
  ↓
AMD（RequireJS）/ CMD（Sea.js）
  ↓
UMD（兼容方案）
  ↓
ES6 Module（官方标准，未来趋势）✅
```

### 4.2 核心要点

1. **模块化是前端工程化的基础**
2. **ES6 Module 是未来标准**，现代项目应优先使用
3. **理解不同规范的特点**，有助于阅读和维护旧代码
4. **构建工具**（Webpack、Vite 等）让模块化开发更加便捷
5. **Tree Shaking** 等优化技术依赖于 ES6 Module 的静态特性